# ReadMe

`include` directory is the place for headers.

`src` directory is the place for source files.

`CMakeLists.txt` is the makefile for build system.

You need to have a working c++ compiler like visual c++. You can install vs2019 on windows, or mingw64 gcc.

You can install mingw64 from:
https://www.msys2.org/ 
add system path of `/msys2/usr/bin` and `/msys2/mingw64/bin`
and start the bash terminal, type:
```bash
pacman -Syu 
pacman -S mingw-w64-x86_64-gcc 
```
to install the mingw64 gcc.

You need to install CMake and set the system path for the exe.

The visual studio code is a good editor to write code. C++ CMake and CMake Tools extensions are needed for CMake project environment. 

On Windows, you need to install the Ninjia build system for CMake Tools extension.

Steps:
1. build a cmake project and import flecs and Raylib.
2. build a ecs world, write main function and add some entities\component\system functions.


双人贪吃蛇系统  
零、    游戏规则  
双人游戏，起始分数的基础上，发生碰撞则扣分，吃到食物则加分。  
游戏停止的触发条件：双方有一方分数变为0，玩家选择结束游戏，或玩家强行关闭窗口。前两种情况停止后，会显示出双方分数和获胜方。  
一、	基本设计思想  
使用Flecs和Raylib框架制作一个双人贪吃蛇游戏。Flecs 是一个用C编写的轻量级Entity-Component-System框架，它允许创建可扩展和高性能的游戏和应用程序。  
在开始实现网络通信之前，首先设计和实现游戏程序。以下是游戏开发的一些步骤：  
（1）	设计游戏规则和玩法：确定蛇的移动方式、速度、地图大小和界面、食物生成机制等细节。  
（2）	定义实体和组件：使用Flecs框架，定义蛇、食物、地图等实体，以及与这些实体相关的组件，如位置、速度等。  
（3）	实现游戏逻辑：编写处理蛇的移动、碰撞检测、分数计算、游戏状态更新等的逻辑代码。  
（4）	创建本地双人模式：实现一个本地的双人模式，让两个玩家可以在同一台设备上进行游戏。  
在完成上述步骤后，开始实现网络通信功能。以下是实现网络通信的一些步骤：  
（1）	选择网络库：选择一个适合游戏项目的C语言网络库，如libevent、libuv或者enet等。  
（2）	设计通信协议：确定客户端与服务器之间通信的数据格式，如游戏状态、用户输入、游戏结果等信息。  
（3）	实现客户端和服务器：客户端负责发送用户输入和接收游戏状态更新，服务器负责处理游戏逻辑和更新游戏状态，然后将状态信息发送给客户端。  
（4）	实现多人同步：确保不同客户端之间的游戏状态同步，处理网络延迟和丢包等问题。  
（5）	当网络通信实现完成后，将拥有一个可以在线进行双人游戏的贪吃蛇游戏。注意在开发过程中进行充分的测试和调试，以确保游戏性能和稳定性。  
二、	ECS框架设计  
实体：  
（1）	蛇（Snake）：每个玩家控制一条蛇。蛇的实体包括蛇头和蛇身的各个部分。每个蛇部分都有自己的位置和其他相关属性。  
（2）	食物（Food）：食物是蛇吃的目标。食物在地图上随机生成，当蛇头吃到食物时，蛇会变长，同时食物会在地图上的另一个随机位置重新生成。  
（3）	地图（Map）：地图实体定义了游戏区域的大小和边界。你可以通过地图实体来控制游戏区域的显示和碰撞检测。  
（4）	玩家（Player）：玩家实体代表游戏中的每个参与者。玩家实体可以包含玩家的分数、输入状态等信息。  
（5）	游戏状态（GameState）：游戏状态实体包含了游戏的整体状态信息，如当前游戏是否正在进行、哪个玩家获胜等。  
组件：  
（1）	位置（Position）组件：表示实体在游戏地图上的坐标。位置组件可用于蛇、食物和地图边界等实体。  
（2）	速度（Velocity）组件：表示实体的移动速度和方向。在贪吃蛇游戏中，速度组件主要用于蛇头实体，用于控制蛇的移动。  
（3）	蛇（Snake）组件：标识实体为蛇的一部分（蛇头或蛇身）。蛇组件可以包含蛇的长度、颜色等属性。  
（4）	食物（Food）组件：标识实体为食物。食物组件可以包含食物的类型、分值等属性。  
（5）	玩家（Player）组件：表示实体为玩家。玩家组件可以包含玩家的id、输入状态等信息。  
（6）	分数（Score）组件：表示玩家的得分。分数组件可以包含玩家当前的分数值。  
（7）	地图（Map）组件：表示实体为游戏地图。地图组件可以包含地图的大小、边界等属性。   
系统：  
（1）	蛇移动系统snake_movement_system：负责处理蛇的移动逻辑，包括根据蛇头方向更新蛇身体部位的位置。   
（2）	碰撞检测系统：负责检测蛇与地图边界、自身和其他玩家的蛇之间的碰撞。当检测到碰撞时，更新游戏状态（如游戏结束或者蛇的生长）。  
（3）	食物生成系统food_generation_system：负责在地图上生成食物，确保食物的位置不与蛇身体重叠。    
（4）	输入处理系统：负责处理玩家的输入，如改变蛇头的移动方向。    
（5）	渲染系统：负责绘制游戏界面，包括蛇、食物和地图。    
（6）	状态更新系统：负责更新游戏状态，如分数、游戏结束状态等。    
（7）	音效系统（可选）：负责处理游戏音效，如蛇吃到食物时播放音效。    
主函数：    
（1）	初始化ECS世界（World）：创建一个ECS世界实例，该实例用于管理实体、组件和系统。   
（2）	注册组件：在ECS世界中注册与游戏实体相关的组件。例如，位置组件、速度组件、分数组件等。   
（3）	注册系统：在ECS世界中注册游戏的各个系统。例如，移动系统、碰撞检测系统、食物生成系统等。 
（4）	创建实体：根据游戏需求创建实体并添加相应组件。例如，创建蛇实体、食物实体、地图实体等。  
（5）	设置游戏循环：实现游戏循环，以固定时间间隔执行ECS世界中的系统更新。 
（6）	清理资源：在游戏结束时，清理ECS世界中的资源和内存。 
三、	基于AI逻辑更新蛇头的移动方向    
另一个玩家可以是基于AI控制的蛇。    
AI逻辑更新蛇头的移动方向是指使用人工智能（AI）算法来控制蛇头的移动，而不是依赖于玩家的输入。在这种情况下，蛇会自动根据AI算法的决策来改变移动方向。例如，AI可以使蛇自动朝着食物移动，规避障碍物，或采取其他策略以获得更高的得分。    

实现AI逻辑更新蛇头的移动方向通常需要以下步骤：  
（1）	分析游戏环境：AI需要了解蛇头、蛇身体、食物以及其他可能存在的障碍物的位置。  
（2）	制定策略：基于当前游戏环境，AI需要决定最佳的移动策略。这可能包括寻找食物、避免碰撞或使用其他高级策略。  
（3）	计算新方向：根据制定的策略，AI需要计算蛇头应该朝哪个方向移动。这可能需要评估多个可能的移动方向，并选择一个最佳方向。    
（4）	更新蛇头方向：将计算出的新方向应用于蛇头，使蛇按照AI算法的决策移动。    
实现这种AI逻辑可以让贪吃蛇游戏变得更有趣和具有挑战性，因为玩家需要与计算机对抗，而不仅仅是控制蛇避免碰撞。这种AI逻辑也可以用于创建单人游戏中的自动演示，让蛇自动玩游戏，以展示游戏的玩法和特点。    

